import {
  __commonJS
} from "./chunk-ZS7NZCD4.js";

// ../JotaiDevToolV/node_modules/javascript-stringify/dist/quote.js
var require_quote = __commonJS({
  "../JotaiDevToolV/node_modules/javascript-stringify/dist/quote.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringifyPath = exports.quoteKey = exports.isValidVariableName = exports.IS_VALID_IDENTIFIER = exports.quoteString = void 0;
    var ESCAPABLE = /[\\\'\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var META_CHARS = /* @__PURE__ */ new Map([
      ["\b", "\\b"],
      ["	", "\\t"],
      ["\n", "\\n"],
      ["\f", "\\f"],
      ["\r", "\\r"],
      ["'", "\\'"],
      ['"', '\\"'],
      ["\\", "\\\\"]
    ]);
    function escapeChar(char) {
      return META_CHARS.get(char) || `\\u${`0000${char.charCodeAt(0).toString(16)}`.slice(-4)}`;
    }
    function quoteString(str) {
      return `'${str.replace(ESCAPABLE, escapeChar)}'`;
    }
    exports.quoteString = quoteString;
    var RESERVED_WORDS = new Set("break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield".split(" "));
    exports.IS_VALID_IDENTIFIER = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
    function isValidVariableName(name) {
      return typeof name === "string" && !RESERVED_WORDS.has(name) && exports.IS_VALID_IDENTIFIER.test(name);
    }
    exports.isValidVariableName = isValidVariableName;
    function quoteKey(key, next) {
      return isValidVariableName(key) ? key : next(key);
    }
    exports.quoteKey = quoteKey;
    function stringifyPath(path, next) {
      let result = "";
      for (const key of path) {
        if (isValidVariableName(key)) {
          result += `.${key}`;
        } else {
          result += `[${next(key)}]`;
        }
      }
      return result;
    }
    exports.stringifyPath = stringifyPath;
  }
});

// ../JotaiDevToolV/node_modules/javascript-stringify/dist/function.js
var require_function = __commonJS({
  "../JotaiDevToolV/node_modules/javascript-stringify/dist/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionParser = exports.dedentFunction = exports.functionToString = exports.USED_METHOD_KEY = void 0;
    var quote_1 = require_quote();
    var METHOD_NAMES_ARE_QUOTED = {
      " "() {
      }
    }[" "].toString().charAt(0) === '"';
    var FUNCTION_PREFIXES = {
      Function: "function ",
      GeneratorFunction: "function* ",
      AsyncFunction: "async function ",
      AsyncGeneratorFunction: "async function* "
    };
    var METHOD_PREFIXES = {
      Function: "",
      GeneratorFunction: "*",
      AsyncFunction: "async ",
      AsyncGeneratorFunction: "async *"
    };
    var TOKENS_PRECEDING_REGEXPS = new Set("case delete else in instanceof new return throw typeof void , ; : + - ! ~ & | ^ * / % < > ? =".split(" "));
    exports.USED_METHOD_KEY = /* @__PURE__ */ new WeakSet();
    var functionToString = (fn, space, next, key) => {
      const name = typeof key === "string" ? key : void 0;
      if (name !== void 0)
        exports.USED_METHOD_KEY.add(fn);
      return new FunctionParser(fn, space, next, name).stringify();
    };
    exports.functionToString = functionToString;
    function dedentFunction(fnString) {
      let found;
      for (const line of fnString.split("\n").slice(1)) {
        const m = /^[\s\t]+/.exec(line);
        if (!m)
          return fnString;
        const [str] = m;
        if (found === void 0)
          found = str;
        else if (str.length < found.length)
          found = str;
      }
      return found ? fnString.split(`
${found}`).join("\n") : fnString;
    }
    exports.dedentFunction = dedentFunction;
    var FunctionParser = class {
      constructor(fn, indent, next, key) {
        this.fn = fn;
        this.indent = indent;
        this.next = next;
        this.key = key;
        this.pos = 0;
        this.hadKeyword = false;
        this.fnString = Function.prototype.toString.call(fn);
        this.fnType = fn.constructor.name;
        this.keyQuote = key === void 0 ? "" : quote_1.quoteKey(key, next);
        this.keyPrefix = key === void 0 ? "" : `${this.keyQuote}:${indent ? " " : ""}`;
        this.isMethodCandidate = key === void 0 ? false : this.fn.name === "" || this.fn.name === key;
      }
      stringify() {
        const value = this.tryParse();
        if (!value) {
          return `${this.keyPrefix}void ${this.next(this.fnString)}`;
        }
        return dedentFunction(value);
      }
      getPrefix() {
        if (this.isMethodCandidate && !this.hadKeyword) {
          return METHOD_PREFIXES[this.fnType] + this.keyQuote;
        }
        return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];
      }
      tryParse() {
        if (this.fnString[this.fnString.length - 1] !== "}") {
          return this.keyPrefix + this.fnString;
        }
        if (this.fn.name) {
          const result = this.tryStrippingName();
          if (result)
            return result;
        }
        const prevPos = this.pos;
        if (this.consumeSyntax() === "class")
          return this.fnString;
        this.pos = prevPos;
        if (this.tryParsePrefixTokens()) {
          const result = this.tryStrippingName();
          if (result)
            return result;
          let offset = this.pos;
          switch (this.consumeSyntax("WORD_LIKE")) {
            case "WORD_LIKE":
              if (this.isMethodCandidate && !this.hadKeyword) {
                offset = this.pos;
              }
            case "()":
              if (this.fnString.substr(this.pos, 2) === "=>") {
                return this.keyPrefix + this.fnString;
              }
              this.pos = offset;
            case '"':
            case "'":
            case "[]":
              return this.getPrefix() + this.fnString.substr(this.pos);
          }
        }
      }
      /**
       * Attempt to parse the function from the current position by first stripping
       * the function's name from the front. This is not a fool-proof method on all
       * JavaScript engines, but yields good results on Node.js 4 (and slightly
       * less good results on Node.js 6 and 8).
       */
      tryStrippingName() {
        if (METHOD_NAMES_ARE_QUOTED) {
          return;
        }
        let start = this.pos;
        const prefix = this.fnString.substr(this.pos, this.fn.name.length);
        if (prefix === this.fn.name) {
          this.pos += prefix.length;
          if (this.consumeSyntax() === "()" && this.consumeSyntax() === "{}" && this.pos === this.fnString.length) {
            if (this.isMethodCandidate || !quote_1.isValidVariableName(prefix)) {
              start += prefix.length;
            }
            return this.getPrefix() + this.fnString.substr(start);
          }
        }
        this.pos = start;
      }
      /**
       * Attempt to advance the parser past the keywords expected to be at the
       * start of this function's definition. This method sets `this.hadKeyword`
       * based on whether or not a `function` keyword is consumed.
       */
      tryParsePrefixTokens() {
        let posPrev = this.pos;
        this.hadKeyword = false;
        switch (this.fnType) {
          case "AsyncFunction":
            if (this.consumeSyntax() !== "async")
              return false;
            posPrev = this.pos;
          case "Function":
            if (this.consumeSyntax() === "function") {
              this.hadKeyword = true;
            } else {
              this.pos = posPrev;
            }
            return true;
          case "AsyncGeneratorFunction":
            if (this.consumeSyntax() !== "async")
              return false;
          case "GeneratorFunction":
            let token = this.consumeSyntax();
            if (token === "function") {
              token = this.consumeSyntax();
              this.hadKeyword = true;
            }
            return token === "*";
        }
      }
      /**
       * Advance the parser past one element of JavaScript syntax. This could be a
       * matched pair of delimiters, like braces or parentheses, or an atomic unit
       * like a keyword, variable, or operator. Return a normalized string
       * representation of the element parsed--for example, returns '{}' for a
       * matched pair of braces. Comments and whitespace are skipped.
       *
       * (This isn't a full parser, so the token scanning logic used here is as
       * simple as it can be. As a consequence, some things that are one token in
       * JavaScript, like decimal number literals or most multi-character operators
       * like '&&', are split into more than one token here. However, awareness of
       * some multi-character sequences like '=>' is necessary, so we match the few
       * of them that we care about.)
       */
      consumeSyntax(wordLikeToken) {
        const m = this.consumeMatch(/^(?:([A-Za-z_0-9$\xA0-\uFFFF]+)|=>|\+\+|\-\-|.)/);
        if (!m)
          return;
        const [token, match] = m;
        this.consumeWhitespace();
        if (match)
          return wordLikeToken || match;
        switch (token) {
          case "(":
            return this.consumeSyntaxUntil("(", ")");
          case "[":
            return this.consumeSyntaxUntil("[", "]");
          case "{":
            return this.consumeSyntaxUntil("{", "}");
          case "`":
            return this.consumeTemplate();
          case '"':
            return this.consumeRegExp(/^(?:[^\\"]|\\.)*"/, '"');
          case "'":
            return this.consumeRegExp(/^(?:[^\\']|\\.)*'/, "'");
        }
        return token;
      }
      consumeSyntaxUntil(startToken, endToken) {
        let isRegExpAllowed = true;
        for (; ; ) {
          const token = this.consumeSyntax();
          if (token === endToken)
            return startToken + endToken;
          if (!token || token === ")" || token === "]" || token === "}")
            return;
          if (token === "/" && isRegExpAllowed && this.consumeMatch(/^(?:\\.|[^\\\/\n[]|\[(?:\\.|[^\]])*\])+\/[a-z]*/)) {
            isRegExpAllowed = false;
            this.consumeWhitespace();
          } else {
            isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);
          }
        }
      }
      consumeMatch(re) {
        const m = re.exec(this.fnString.substr(this.pos));
        if (m)
          this.pos += m[0].length;
        return m;
      }
      /**
       * Advance the parser past an arbitrary regular expression. Return `token`,
       * or the match object of the regexp.
       */
      consumeRegExp(re, token) {
        const m = re.exec(this.fnString.substr(this.pos));
        if (!m)
          return;
        this.pos += m[0].length;
        this.consumeWhitespace();
        return token;
      }
      /**
       * Advance the parser past a template string.
       */
      consumeTemplate() {
        for (; ; ) {
          this.consumeMatch(/^(?:[^`$\\]|\\.|\$(?!{))*/);
          if (this.fnString[this.pos] === "`") {
            this.pos++;
            this.consumeWhitespace();
            return "`";
          }
          if (this.fnString.substr(this.pos, 2) === "${") {
            this.pos += 2;
            this.consumeWhitespace();
            if (this.consumeSyntaxUntil("{", "}"))
              continue;
          }
          return;
        }
      }
      /**
       * Advance the parser past any whitespace or comments.
       */
      consumeWhitespace() {
        this.consumeMatch(/^(?:\s|\/\/.*|\/\*[^]*?\*\/)*/);
      }
    };
    exports.FunctionParser = FunctionParser;
  }
});

// ../JotaiDevToolV/node_modules/javascript-stringify/dist/array.js
var require_array = __commonJS({
  "../JotaiDevToolV/node_modules/javascript-stringify/dist/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrayToString = void 0;
    var arrayToString = (array, space, next) => {
      const values = array.map(function(value, index) {
        const result = next(value, index);
        if (result === void 0)
          return String(result);
        return space + result.split("\n").join(`
${space}`);
      }).join(space ? ",\n" : ",");
      const eol = space && values ? "\n" : "";
      return `[${eol}${values}${eol}]`;
    };
    exports.arrayToString = arrayToString;
  }
});

// ../JotaiDevToolV/node_modules/javascript-stringify/dist/object.js
var require_object = __commonJS({
  "../JotaiDevToolV/node_modules/javascript-stringify/dist/object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objectToString = void 0;
    var quote_1 = require_quote();
    var function_1 = require_function();
    var array_1 = require_array();
    var objectToString = (value, space, next, key) => {
      if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
        return `Buffer.from(${next(value.toString("base64"))}, 'base64')`;
      }
      if (typeof global === "object" && value === global) {
        return globalToString(value, space, next, key);
      }
      const toString = OBJECT_TYPES[Object.prototype.toString.call(value)];
      return toString ? toString(value, space, next, key) : void 0;
    };
    exports.objectToString = objectToString;
    var rawObjectToString = (obj, indent, next, key) => {
      const eol = indent ? "\n" : "";
      const space = indent ? " " : "";
      const values = Object.keys(obj).reduce(function(values2, key2) {
        const fn = obj[key2];
        const result = next(fn, key2);
        if (result === void 0)
          return values2;
        const value = result.split("\n").join(`
${indent}`);
        if (function_1.USED_METHOD_KEY.has(fn)) {
          values2.push(`${indent}${value}`);
          return values2;
        }
        values2.push(`${indent}${quote_1.quoteKey(key2, next)}:${space}${value}`);
        return values2;
      }, []).join(`,${eol}`);
      if (values === "")
        return "{}";
      return `{${eol}${values}${eol}}`;
    };
    var globalToString = (value, space, next) => {
      return `Function(${next("return this")})()`;
    };
    var OBJECT_TYPES = {
      "[object Array]": array_1.arrayToString,
      "[object Object]": rawObjectToString,
      "[object Error]": (error, space, next) => {
        return `new Error(${next(error.message)})`;
      },
      "[object Date]": (date) => {
        return `new Date(${date.getTime()})`;
      },
      "[object String]": (str, space, next) => {
        return `new String(${next(str.toString())})`;
      },
      "[object Number]": (num) => {
        return `new Number(${num})`;
      },
      "[object Boolean]": (bool) => {
        return `new Boolean(${bool})`;
      },
      "[object Set]": (set, space, next) => {
        return `new Set(${next(Array.from(set))})`;
      },
      "[object Map]": (map, space, next) => {
        return `new Map(${next(Array.from(map))})`;
      },
      "[object RegExp]": String,
      "[object global]": globalToString,
      "[object Window]": globalToString
    };
  }
});

// ../JotaiDevToolV/node_modules/javascript-stringify/dist/stringify.js
var require_stringify = __commonJS({
  "../JotaiDevToolV/node_modules/javascript-stringify/dist/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toString = void 0;
    var quote_1 = require_quote();
    var object_1 = require_object();
    var function_1 = require_function();
    var PRIMITIVE_TYPES = {
      string: quote_1.quoteString,
      number: (value) => Object.is(value, -0) ? "-0" : String(value),
      boolean: String,
      symbol: (value, space, next) => {
        const key = Symbol.keyFor(value);
        if (key !== void 0)
          return `Symbol.for(${next(key)})`;
        return `Symbol(${next(value.description)})`;
      },
      bigint: (value, space, next) => {
        return `BigInt(${next(String(value))})`;
      },
      undefined: String,
      object: object_1.objectToString,
      function: function_1.functionToString
    };
    var toString = (value, space, next, key) => {
      if (value === null)
        return "null";
      return PRIMITIVE_TYPES[typeof value](value, space, next, key);
    };
    exports.toString = toString;
  }
});

// ../JotaiDevToolV/node_modules/javascript-stringify/dist/index.js
var require_dist = __commonJS({
  "../JotaiDevToolV/node_modules/javascript-stringify/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = void 0;
    var stringify_1 = require_stringify();
    var quote_1 = require_quote();
    var ROOT_SENTINEL = Symbol("root");
    function stringify(value, replacer, indent, options = {}) {
      const space = typeof indent === "string" ? indent : " ".repeat(indent || 0);
      const path = [];
      const stack = /* @__PURE__ */ new Set();
      const tracking = /* @__PURE__ */ new Map();
      const unpack = /* @__PURE__ */ new Map();
      let valueCount = 0;
      const { maxDepth = 100, references = false, skipUndefinedProperties = false, maxValues = 1e5 } = options;
      const valueToString = replacerToString(replacer);
      const onNext = (value2, key) => {
        if (++valueCount > maxValues)
          return;
        if (skipUndefinedProperties && value2 === void 0)
          return;
        if (path.length > maxDepth)
          return;
        if (key === void 0)
          return valueToString(value2, space, onNext, key);
        path.push(key);
        const result2 = builder(value2, key === ROOT_SENTINEL ? void 0 : key);
        path.pop();
        return result2;
      };
      const builder = references ? (value2, key) => {
        if (value2 !== null && (typeof value2 === "object" || typeof value2 === "function" || typeof value2 === "symbol")) {
          if (tracking.has(value2)) {
            unpack.set(path.slice(1), tracking.get(value2));
            return valueToString(void 0, space, onNext, key);
          }
          tracking.set(value2, path.slice(1));
        }
        return valueToString(value2, space, onNext, key);
      } : (value2, key) => {
        if (stack.has(value2))
          return;
        stack.add(value2);
        const result2 = valueToString(value2, space, onNext, key);
        stack.delete(value2);
        return result2;
      };
      const result = onNext(value, ROOT_SENTINEL);
      if (unpack.size) {
        const sp = space ? " " : "";
        const eol = space ? "\n" : "";
        let wrapper = `var x${sp}=${sp}${result};${eol}`;
        for (const [key, value2] of unpack.entries()) {
          const keyPath = quote_1.stringifyPath(key, onNext);
          const valuePath = quote_1.stringifyPath(value2, onNext);
          wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;
        }
        return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;
      }
      return result;
    }
    exports.stringify = stringify;
    function replacerToString(replacer) {
      if (!replacer)
        return stringify_1.toString;
      return (value, space, next, key) => {
        return replacer(value, space, (value2) => stringify_1.toString(value2, space, next, key), key);
      };
    }
  }
});
export default require_dist();
//# sourceMappingURL=javascript-stringify.js.map
